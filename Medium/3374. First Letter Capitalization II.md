Table: user_content

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| content_id  | int     |
| content_text| varchar |
+-------------+---------+
content_id is the unique key for this table.
Each row contains a unique ID and the corresponding text content.

Write a solution to transform the text in the content_text column by applying the following rules:

    Convert the first letter of each word to uppercase and the remaining letters to lowercase
    Special handling for words containing special characters:
        For words connected with a hyphen -, both parts should be capitalized (e.g., top-rated → Top-Rated)
    All other formatting and spacing should remain unchanged

Return the result table that includes both the original content_text and the modified text following the above rules.

The result format is in the following example.

 

Example:

Input:

user_content table:

+------------+---------------------------------+
| content_id | content_text                    |
+------------+---------------------------------+
| 1          | hello world of SQL              |
| 2          | the QUICK-brown fox             |
| 3          | modern-day DATA science         |
| 4          | web-based FRONT-end development |
+------------+---------------------------------+

Output:

+------------+---------------------------------+---------------------------------+
| content_id | original_text                   | converted_text                  |
+------------+---------------------------------+---------------------------------+
| 1          | hello world of SQL              | Hello World Of Sql              |
| 2          | the QUICK-brown fox             | The Quick-Brown Fox             |
| 3          | modern-day DATA science         | Modern-Day Data Science         |
| 4          | web-based FRONT-end development | Web-Based Front-End Development |
+------------+---------------------------------+---------------------------------+

Explanation:

    For content_id = 1:
        Each word's first letter is capitalized: "Hello World Of Sql"
    For content_id = 2:
        Contains the hyphenated word "QUICK-brown" which becomes "Quick-Brown"
        Other words follow normal capitalization rules
    For content_id = 3:
        Hyphenated word "modern-day" becomes "Modern-Day"
        "DATA" is converted to "Data"
    For content_id = 4:
        Contains two hyphenated words: "web-based" → "Web-Based"
        And "FRONT-end" → "Front-End"





-----

Procedural Decomposition
Okay, let's tackle this SQL problem. The goal is to transform the content_text based on specific capitalization rules. Hmm, let's break down the requirements first.

So, the first step is to convert each word so that the first letter is uppercase and the rest are lowercase. But there's a special case for hyphenated words. For example, a word like "top-rated" should become "Top-Rated". That means each part before and after the hyphen needs to be capitalized individually. Also, other formatting and spacing should stay the same, so we can't just split on spaces; need to preserve the original spacing.

The challenge here is to handle both regular words and hyphenated words. Let's think about how to split the text into words. Words are separated by spaces, and within a word, hyphens split into subwords. So for each word in the content_text, we need to check if it contains a hyphen. If it does, split it into parts by hyphen, capitalize each part, then join them back with hyphens. Otherwise, just capitalize the word normally.

But how do we do this in SQL? Since SQL doesn't have built-in functions for splitting strings into words and processing them, perhaps we need to use a combination of string functions, or maybe write a custom function. Wait, but the problem says "write a solution", so maybe we can find a way without writing a stored procedure, which might be complex.

Alternatively, maybe use recursive CTEs or some clever string manipulation. Let's think.

Another approach: Split the content_text into words (split by spaces), process each word (split into subwords by hyphen if necessary, capitalize each part), then rejoin with hyphens and spaces. But again, how to split and process each word in SQL.

Wait, but SQL isn't the best at this. Maybe we can use a series of REPLACE, UPPER, LOWER functions with some pattern matching. Let's see.

Let's consider the steps for a single word. For example, take "QUICK-brown". Split into "QUICK" and "brown". Capitalize each part: "Quick" and "Brown", then rejoin as "Quick-Brown".

But how to split on hyphens and process each part. Hmm. Maybe using the STRING_SPLIT function? But that's available in SQL Server, but not sure about other databases. Since the problem doesn't specify the SQL dialect, perhaps assume that some functions are available.

Alternatively, use a combination of SUBSTRING, CHARINDEX, etc. But that's going to get complicated.

Alternatively, perhaps use a user-defined function (UDF) to process each word. For example, create a function that takes a word and returns the properly formatted version.

But creating a UDF might be necessary here, given the complexity. Let's think about that.

First, create a function to process a word with hyphens. Let's call it ProcessHyphenatedWord. This function takes a word and returns the processed version.

The function would split the word into parts separated by hyphens, capitalize each part, then rejoin with hyphens.

For example, for "modern-day", split into "modern" and "day". Capitalize each: "Modern" and "Day", then rejoin as "Modern-Day".

Then, for each word in the content_text, split into words by spaces, process each word with the function, then rejoin with spaces.

But again, how to split into words in SQL. Hmm.

Alternatively, perhaps use a numbers/tally table approach to split the words. Let me think.

Alternatively, maybe use a combination of regex in SQL. But again, SQL Server (for example) doesn't support regex natively, unless using CLR integration. But other databases like PostgreSQL do. The problem statement isn't specific. Hmm, but in the example, the output shows that the original text is preserved, so the converted_text must process each word correctly.

So, perhaps in the solution, we can use a combination of UPPER and LOWER functions, along with string splitting and looping.

Alternatively, here's an approach:

For each word (split by space), split into parts by hyphen. For each part, capitalize the first letter and lowercase the rest. Then join with hyphens. Then, rejoin all words with spaces.

But how to implement this in SQL.

Let me think of the steps for a single word:

1. Split the word into parts separated by hyphens. For example, "FRONT-end" → ["FRONT", "end"].

2. For each part, process it: take the first character, uppercase it, then the rest lowercase. For "FRONT" → "Front", "end" → "End".

3. Rejoin the parts with hyphens: "Front-End".

So, perhaps we can create a function that takes a string and returns the processed string.

But again, creating a function in SQL may be the way to go here.

But the problem says "Write a solution". So perhaps the intended way is to use SQL functions that can handle this.

Wait, maybe the problem can be handled using a combination of SQL string functions. Let's think.

For each word:

- Split into hyphen-separated parts. For example, using a recursive CTE to split on hyphens.

But without a split function, this can be challenging.

Alternatively, use a nested REPLACE function. Not sure.

Alternatively, think of each hyphenated part as a separate token, then process each.

Alternatively, maybe use the INITCAP function, but that's not available in all SQL dialects, and also, INITCAP might not handle hyphens correctly. For example, in Oracle, INITCAP would capitalize letters after hyphens, but maybe not. Let's check.

Wait, in Oracle, INITCAP('hello-world') would return 'Hello-World', which is exactly what we need. But the problem's example requires that hyphenated parts are processed, so maybe that's the case. But the second part's first letter is already capitalized. Wait, in the example, the input for content_id=2 is "the QUICK-brown fox", which becomes "The Quick-Brown Fox". The hyphenated word "QUICK-brown" becomes "Quick-Brown". So each part is processed: first part becomes lowercase except first letter, same for the second part.

But INITCAP may not work here, because in some SQL dialects, INITCAP might not split on hyphens, and thus apply the function to each part. But for example, in Oracle, INITCAP('QUICK-brown') would return 'Quick-Brown', which is correct. Let's verify.

Wait, INITCAP in Oracle converts the first letter of each word to uppercase and the rest to lowercase. A word is considered a sequence of alphanumeric characters separated by white space or non-alphanumeric characters. So, in the case of hyphen, the parts before and after are treated as separate words. So, 'QUICK-brown' would be split into 'QUICK' and 'brown', then converted to 'Quick' and 'Brown', resulting in 'Quick-Brown'. That's exactly what's needed.

If that's the case, then using INITCAP would handle both hyphenated words and regular words. But the problem is that INITCAP is not available in all SQL dialects. For example, MySQL doesn't have INITCAP, and SQL Server doesn't have it either. So maybe the problem expects us to simulate the INITCAP function with some modifications.

But let's think again. The example shows that "DATA" becomes "Data". So the first letter is capitalized, rest lowercase. So using LOWER on the entire word, then capitalizing the first letter.

But how to do that for each word and hyphenated parts.

Hmm. Let's think of the steps again.

For each word (split by spaces):

- Split the word into subwords by hyphens.

- For each subword:

- Convert to lowercase.

- Capitalize the first letter.

- Rejoin the subwords with hyphens.

Then, rejoin all words with spaces.

So, for the entire content_text:

Split into words (split by space), process each word as per above, then join with spaces.

But how to split and process in SQL.

An alternative approach is to use a combination of string functions. For example, for each hyphenated word, replace hyphens with a special delimiter, split into parts, process each part, then rejoin with hyphens.

But without a split function, this is difficult.

Alternatively, use a recursive CTE to split the text into words and subwords.

Wait, perhaps using a recursive CTE to split words and subwords.

Let me outline the steps:

1. Split the original content_text into words separated by spaces.

2. For each word, split into subwords separated by hyphens.

3. For each subword, process to have the first letter uppercase and the rest lowercase.

4. Rejoin the subwords with hyphens.

5. Rejoin the words with spaces.

But how to split the text into words and subwords in SQL.

Alternatively, for each word, replace hyphens with a marker, split into subwords, process each, then replace markers with hyphens.

But this is getting complicated.

Alternatively, create a function that processes a single word (handling hyphens) and then use that function on each word in the content_text.

But how to split the content_text into words and apply the function.

Hmm.

Alternatively, use a numbers table to split the content_text into words. Let's assume that we have a numbers table with numbers from 1 to some maximum value. For each content_text, split into words by spaces, using the numbers to find each word.

But again, how to do that in SQL.

Alternatively, use a recursive CTE to split the content_text into words.

For example, in SQL Server, a recursive CTE can split a string into words separated by spaces. Then, for each word, split into subwords separated by hyphens using another recursive CTE.

But this would involve multiple levels of recursion.

This seems possible but very involved.

Let me think about writing such a query.

First, split the content_text into words:

For example, for "the QUICK-brown fox", split into ["the", "QUICK-brown", "fox"].

Then, for each word, split into subwords by hyphen. So "QUICK-brown" becomes ["QUICK", "brown"].

Then, for each subword, process to uppercase first letter and lowercase the rest. So "QUICK" becomes "Quick", "brown" becomes "Brown".

Rejoin with hyphens: "Quick-Brown".

Rejoin all words with spaces: "The Quick-Brown Fox".

So, the process involves multiple steps.

Let's outline the steps for SQL:

1. Split the content_text into individual words, preserving the order. Each word is separated by spaces.

2. For each word, split into subwords separated by hyphens.

3. For each subword, process to capitalize the first letter and lowercase the rest.

4. Rejoin the subwords with hyphens.

5. Rejoin the processed words with spaces to form the converted_text.

But how to split into words and subwords. Let's attempt to model this with recursive CTEs.

First, split into words:

Using a recursive CTE to split the content_text into words:

For example, for the content_text, we can find the position of the first space, extract the first word, then the remaining string, and repeat.

But in SQL, this can be done with a recursive CTE.

Then, for each word, split into subwords by hyphens similarly.

Alternatively, use STRING_SPLIT, but that's not order-preserving in SQL Server. So that's a problem. So the order of words may not be maintained.

But since the problem requires maintaining the original spacing, perhaps the order is important.

Alternatively, since the examples show that the output has the same spacing as the input (like "web-based FRONT-end development" becomes "Web-Based Front-End Development"), the splitting into words must be done by splitting on spaces and preserving the order.

Hmm. So if we use STRING_SPLIT, but in a way that preserves order, but I don't think that's possible in SQL Server. So maybe the recursive CTE approach is necessary.

But perhaps this is getting too complex. Let's think of another approach.

Another Idea: Use a sequence of REPLACE and string functions to capitalize each character appropriately.

But how?

Wait, perhaps for each character in the string, check if it is the start of a word or a subword (after a hyphen), then capitalize it, and lowercase the rest.

But this would require processing each character, which is difficult in SQL.

Alternatively, create a scalar function that processes the entire string according to the rules.

For example, create a function called FormatText that takes a string and returns the formatted string.

The function would loop through each character, track when a new word or subword starts (after space or hyphen), capitalize the first character, and lowercase others.

But writing such a function in SQL is possible but requires procedural code.

In SQL Server, this could be done with a T-SQL function. For example:

CREATE FUNCTION dbo.FormatText (@input VARCHAR(MAX))

RETURNS VARCHAR(MAX)

AS

BEGIN

DECLARE @output VARCHAR(MAX) = ''

DECLARE @i INT = 1

DECLARE @len INT = LEN(@input)

DECLARE @prevChar CHAR(1)

DECLARE @currentChar CHAR(1)

DECLARE @isNewWord BIT = 1

WHILE @i <= @len

BEGIN

SET @currentChar = SUBSTRING(@input, @i, 1)

IF @isNewWord = 1

BEGIN

SET @output = @output + UPPER(@currentChar)

SET @isNewWord = 0

END

ELSE

SET @output = @output + LOWER(@currentChar)

IF @currentChar = ' ' OR @currentChar = '-'

BEGIN

SET @isNewWord = 1

END

ELSE

SET @isNewWord = 0

SET @i = @i + 1

END

RETURN @output

END

This function would process each character, capitalizing the first character after a space or hyphen, and lowercasing the rest.

Wait, let's test this logic.

For example, the input 'hello world' would become 'Hello World'.

For 'the QUICK-brown fox', the function would process each character:

After 'the ', the next character is 'Q' → since previous was space, uppercase → 'The '.

Then 'U' → since not new word → lowercase → 'u'.

So 'QUICK' becomes 'Quick'.

Then '-b' → the hyphen sets @isNewWord=1, so 'b' becomes 'B' → 'Quick-Brown'.

So the hyphenated parts would be handled correctly.

So this function seems to handle both regular words and hyphenated words.

This would process the entire string correctly, according to the problem's requirements.

If that's the case, then the solution can be to write this function and use it in the query.

Then, the SQL query would be:

SELECT content_id,

content_text AS original_text,

dbo.FormatText(content_text) AS converted_text

FROM user_content;

But the problem is that this requires creating a function, which may not be possible in some environments. However, the problem says to "write a solution", which could include creating a function.

But perhaps the problem expects a pure SQL solution without using user-defined functions.

Alternatively, if the SQL dialect supports some form of INITCAP that handles hyphens, but as discussed earlier, that's not the case in all systems.

Alternatively, let's test the function approach.

For example, in the sample input:

For content_id=2: "the QUICK-brown fox" → the function would process as:

t → T (new word starts)

h → h (lowercase)

e → e

space → new word flag set

Q → Q (capitalized)

U → u (lowercase)

I → i

C → c

K → k

- → hyphen sets new word flag

b → B (capitalized)

r → r

o → o

w → w

n → n

space → new word flag

f → F

o → o

x → x

Resulting in "The Quick-Brown Fox".

Which matches the sample output.

Similarly, for "web-based FRONT-end development", the function would process:

w → W (new word)

e → e

b → b

- → hyphen → new word

b → B

a → a

s → s

e → e

d → d

space → new word

F → F (capitalized)

R → r

O → o

N → n

T → t

- → hyphen → new word

e → E

n → n

d → d

... etc.

Resulting in "Web-Based Front-End Development".

This seems to handle all cases correctly.

So creating this function is a viable solution.

Now, the problem is to write the SQL query using this function. Assuming that the function is allowed, then the solution is straightforward.

But the question is, how to handle this in a SQL query without using a UDF, which might be required in some scenarios.

Alternatively, maybe the problem is designed to use some combination of string functions.

Another Idea: Use a combination of UPPER, LOWER, and string functions to capitalize the first letter of each word and hyphenated part.

For example, for each hyphenated part, split into parts, capitalize each, and rejoin.

But without splitting, perhaps it's possible.

Wait, for a single word like 'hello-world', the desired output is 'Hello-World'. To do this, the first character and the character after each hyphen should be uppercase, others lowercase.

So, perhaps:

1. Convert the entire string to lowercase.

2. Capitalize the first character.

3. Capitalize the character after each hyphen.

But how to implement this in SQL.

For example, take the content_text and:

- Convert to lowercase.

- Use REPLACE to find hyphens followed by a character, and uppercase that character.

But how to do that.

Alternatively, using nested REPLACE functions for each possible character after a hyphen, but that's impractical.

Alternatively, use a combination of STUFF and CHARINDEX to find hyphens and uppercase the next character.

But this approach would require multiple steps and handling all possible positions of hyphens.

Alternatively, use a recursive CTE to process each character in the string.

For example:

WITH cte AS (

SELECT

content_id,

content_text,

1 AS pos,

LOWER(SUBSTRING(content_text, 1, 1)) AS converted_char,

CASE WHEN SUBSTRING(content_text, 1, 1) IN (' ', '-') THEN 1 ELSE 0 END AS next_cap

FROM user_content

UNION ALL

SELECT

content_id,

content_text,

pos + 1,

CASE

WHEN next_cap = 1 THEN UPPER(SUBSTRING(content_text, pos + 1, 1))

ELSE LOWER(SUBSTRING(content_text, pos + 1, 1))

END,

CASE

WHEN SUBSTRING(content_text, pos + 1, 1) IN (' ', '-') THEN 1

ELSE 0

END

FROM cte

WHERE pos < LEN(content_text)

)

SELECT content_id, content_text,

(SELECT STRING_AGG(converted_char, '') WITHIN GROUP (ORDER BY pos) AS converted_text

FROM cte

GROUP BY content_id, content_text;

But this is a bit complex. Let's break it down.

The CTE starts at position 1. For each position, it checks if the next character should be capitalized (based on the previous character being a space or hyphen). The 'next_cap' flag is set to 1 if the current character is a space or hyphen, which would mean that the next character should be capitalized.

Then, for each character, it applies lowercase unless the 'next_cap' flag is 1, in which case it uppercases the character.

But wait, the first character is processed as lowercase, but according to the rules, the first character of the first word should be uppercase. So the initial part of the CTE sets the first character to lowercase and the next_cap flag. But this would cause the first character to be lowercase. That's wrong.

So the initial step should capitalize the first character. Let's adjust:

In the CTE:

SELECT

content_id,

content_text,

1 AS pos,

UPPER(SUBSTRING(content_text, 1, 1)) AS converted_char,

CASE WHEN SUBSTRING(content_text, 1, 1) IN (' ', '-') THEN 1 ELSE 0 END AS next_cap

FROM user_content

Then, for the next positions:

CASE

WHEN next_cap = 1 THEN UPPER(SUBSTRING(content_text, pos + 1, 1))

ELSE LOWER(SUBSTRING(content_text, pos + 1, 1))

END,

But this way, the first character is uppercased. Then, after a space or hyphen, the next character is uppercased.

But what about the rest of the characters? For example, in "hello", the first 'h' is uppercase, then the rest are lowercase.

Yes, this seems to work.

Let's test this with the example input.

For content_id=2, content_text is "the QUICK-brown fox".

Processing each character:

pos 1: 't' → uppercase → 'T', next_cap is 0 (since 'T' is not space or hyphen).

pos 2: 'h' → lowercase → 'h', next_cap 0.

pos 3: 'e' → lowercase → 'e', next_cap 0.

pos 4: ' ' → since previous was 'e', which is not a space or hyphen. So converted_char is ' ' (space), next_cap is 1 (because current character is space).

pos 5: 'Q' → next_cap is 1 → uppercase → 'Q', next_cap 0 (since 'Q' is not space or hyphen).

Wait, but according to the code, the next_cap is determined by the current character. So when processing pos 5 (character 'Q'), the code looks at the current character (after processing the space). The next_cap is set to 1 because the previous character (pos 4) was a space. So the 'Q' is uppercased. Then, the next_cap is set based on the current character (pos 5, 'Q' is not space or hyphen) → next_cap 0.

pos 6: 'U' → next_cap is 0 → lowercase → 'u'.

And so on.

This way, after a space or hyphen, the next character is capitalized.

But this approach would handle both spaces and hyphens. So hyphenated words would have their parts capitalized.

Let's see:

Take 'modern-day' → becomes 'Modern-Day'.

Processing:

'm' → 'M', next_cap 0.

Then each character until '-', which is processed as a hyphen. The hyphen is converted to '-', and next_cap is set to 1. Then 'd' is uppercased to 'D', and next_cap 0. The rest of the characters in 'day' are lowercased.

So the result is 'Modern-Day'.

Similarly, 'FRONT-end' would become 'Front-End'.

But wait, the input is 'FRONT-end'. Let's process:

F → 'F', next_cap 0.

R → 'r' (lowercase).

O → 'o'.

N → 'n'.

T → 't'.

- → '-', next_cap 1.

e → 'E' (uppercase), next_cap 0.

n → 'n'.

d → 'd'.

So the result is 'Front-End'.

This seems correct.

So this approach would handle all the cases correctly.

So the recursive CTE approach would work.

But how to implement this in SQL.

The CTE would generate each character of the content_text, applying the conversion rules. Then, we can aggregate all characters back into a string.

In SQL Server, using STRING_AGG with the ordered pos would reconstruct the string.

So the final query would look like this:

WITH cte AS (

SELECT

content_id,

content_text,

1 AS pos,

UPPER(SUBSTRING(content_text, 1, 1)) AS converted_char,

CASE WHEN SUBSTRING(content_text, 1, 1) IN (' ', '-') THEN 1 ELSE 0 END AS next_cap

FROM user_content

UNION ALL

SELECT

content_id,

content_text,

pos + 1,

CASE

WHEN next_cap = 1 THEN UPPER(SUBSTRING(content_text, pos + 1, 1))

ELSE LOWER(SUBSTRING(content_text, pos + 1, 1))

END,

CASE

WHEN SUBSTRING(content_text, pos + 1, 1) IN (' ', '-') THEN 1

ELSE 0

END

FROM cte

WHERE pos < LEN(content_text)

)

SELECT

content_id,

MAX(content_text) AS original_text,

STRING_AGG(converted_char, '') WITHIN GROUP (ORDER BY pos) AS converted_text

FROM cte

GROUP BY content_id;

But this requires that the CTE runs for each character in each content_text. For large texts, this could be slow. But for the purpose of the problem, assuming the inputs are manageable, this would work.

However, this approach has a problem: the initial part of the CTE assumes that the content_text is not empty. But that's probably handled by the problem's constraints.

Testing this with the sample input:

For content_id=2, the content_text is "the QUICK-brown fox".

The first character 't' becomes 'T', next_cap=0.

Next character 'h' → lowercase, next_cap=0.

Next character 'e' → lowercase, next_cap=0.

Next character ' ' → converted_char is ' ', next_cap=1.

Next character 'Q' → next_cap=1 → 'Q', next_cap=0.

Next character 'U' → next_cap=0 → 'u'.

And so on. This would produce "The Quick-Brown Fox".

Which is correct.

So this approach works.

But the problem is the use of STRING_AGG, which is available in SQL Server 2017 and later, and other databases may have similar functions. If the database doesn't support STRING_AGG, then another approach would be needed.

But assuming that the SQL environment supports STRING_AGG, this solution should work.

So the final query would involve this CTE.

But then, the problem is that the original_text should be the same as content_text. The query selects MAX(content_text) AS original_text, which should be correct since content_text is grouped by content_id.

Thus, the solution would be:

SELECT

content_id,

content_text AS original_text,

(STRING_AGG(converted_char, '') WITHIN GROUP (ORDER BY pos)) AS converted_text

FROM cte

GROUP BY content_id, content_text;

But since content_text is part of the GROUP BY clause, the MAX is not needed.

Alternatively, in the CTE, the content_text is not altered, so grouping by content_id and content_text and selecting content_text is valid.

So the final answer uses this CTE approach.

But now, let's write the full SQL code.

WITH cte AS (

SELECT

content_id,

content_text,

1 AS pos,

UPPER(SUBSTRING(content_text, 1, 1)) AS converted_char,

CASE WHEN SUBSTRING(content_text, 1, 1) IN (' ', '-') THEN 1 ELSE 0 END AS next_cap

FROM user_content

UNION ALL

SELECT

cte.content_id,

cte.content_text,

cte.pos + 1 AS pos,

CASE

WHEN cte.next_cap = 1 THEN UPPER(SUBSTRING(cte.content_text, cte.pos + 1, 1))

ELSE LOWER(SUBSTRING(cte.content_text, cte.pos + 1, 1))

END AS converted_char,

CASE

WHEN SUBSTRING(cte.content_text, cte.pos + 1, 1) IN (' ', '-') THEN 1

ELSE 0

END AS next_cap

FROM cte

WHERE cte.pos < LEN(cte.content_text)

)

SELECT

content_id,

content_text AS original_text,

STRING_AGG(converted_char, '') WITHIN GROUP (ORDER BY pos) AS converted_text

FROM cte

GROUP BY content_id, content_text;

This query should work, but let's check for content_id=1:

Input: "hello world of SQL"

Processing:

First character 'h' → 'H', next_cap=0.

Next characters 'e', 'l', 'l', 'o' → lowercase.

Then space → ' ', next_cap=1.

Next 'w' → 'W', next_cap=0.

And so on. The converted text would be "Hello World Of Sql".

Which matches the sample.

Another test case: 'web-based FRONT-end development' → 'Web-Based Front-End Development'.

Yes.

So this approach should work.

But the problem is that this uses a recursive CTE, which might not be efficient for large texts. However, the problem seems to accept this as a solution.

So the answer is to use this recursive CTE approach.

To solve this problem, we need to transform the text in the content_text column by applying specific capitalization rules. The goal is to convert the first letter of each word to uppercase and the remaining letters to lowercase, with special handling for hyphenated words where each part should be capitalized.
Approach

    Recursive CTE for Character Processing: Use a recursive Common Table Expression (CTE) to process each character in the content_text string. This CTE will iterate through each character, applying the necessary transformations based on the position and context of the character (i.e., after a space or hyphen).

    Capitalization Logic: For each character, check if it should be capitalized (if it follows a space or hyphen) and convert it to uppercase. Otherwise, convert it to lowercase.

    String Aggregation: After processing all characters, aggregate them back into a string to form the transformed text.

Solution Code
sql
Copy

WITH cte AS (
    SELECT 
        content_id,
        content_text,
        1 AS pos,
        UPPER(SUBSTRING(content_text, 1, 1)) AS converted_char,
        CASE WHEN SUBSTRING(content_text, 1, 1) IN (' ', '-') THEN 1 ELSE 0 END AS next_cap
    FROM user_content
    UNION ALL
    SELECT 
        cte.content_id,
        cte.content_text,
        cte.pos + 1 AS pos,
        CASE 
            WHEN cte.next_cap = 1 THEN UPPER(SUBSTRING(cte.content_text, cte.pos + 1, 1))
            ELSE LOWER(SUBSTRING(cte.content_text, cte.pos + 1, 1))
        END AS converted_char,
        CASE 
            WHEN SUBSTRING(cte.content_text, cte.pos + 1, 1) IN (' ', '-') THEN 1 
            ELSE 0 
        END AS next_cap
    FROM cte
    WHERE cte.pos < LEN(cte.content_text)
)
SELECT 
    content_id,
    content_text AS original_text,
    STRING_AGG(converted_char, '') WITHIN GROUP (ORDER BY pos) AS converted_text
FROM cte
GROUP BY content_id, content_text;

Explanation

    Recursive CTE Initialization: The CTE starts by processing the first character of each content_text, converting it to uppercase. It also checks if the first character is a space or hyphen to determine if the next character should be capitalized.

    Recursive Processing: For each subsequent character, the CTE checks if the previous character was a space or hyphen. If so, the current character is converted to uppercase; otherwise, it is converted to lowercase. This check continues recursively for each character in the string.

    String Aggregation: After processing all characters, the STRING_AGG function is used to concatenate the transformed characters back into a single string, preserving the original order.

This approach efficiently processes each character in the text, ensuring that all words and hyphenated parts are correctly capitalized according to the specified rules.
New chat

