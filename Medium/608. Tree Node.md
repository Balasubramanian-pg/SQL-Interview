## Problem: Node Type in Tree

Write a solution to report the type of each node in the tree. Each node can be one of three types: "Leaf", "Root", or "Inner".

**Tables:**

### 1. `Tree` Table

This table contains information about nodes and their parent nodes in a tree structure.

| Column Name | Type | Description                                                                 |
| ----------- | -------- | --------------------------------------------------------------------------- |
| `id`          | `int`  | Unique identifier for each node in the tree.                               |
| `p_id`        | `int`  | ID of the parent node for the current node. `NULL` for the root node.      |

**Primary Key:** `id`

**Node Type Definitions:**

*   **"Leaf"**: A node is a "Leaf" if it is not a root node and it does not have any child nodes.
*   **"Root"**: A node is a "Root" if its `p_id` is `NULL`. A tree will have only one root.
*   **"Inner"**: A node is "Inner" if it is neither a "Leaf" nor a "Root". This means it has a parent and at least one child.

**Constraints:**

*   The given structure is always a valid tree.
*   Each node will be classified into one of the three types: "Leaf", "Root", or "Inner".
*   Return the result table in any order.

**Example Input 1:**

**`Tree` Table:**

| id  | p\_id |
| --- | ----- |
| 1   | null  |
| 2   | 1     |
| 3   | 1     |
| 4   | 2     |
| 5   | 2     |

**Expected Output 1:**

| id  | type  |
| --- | ----- |
| 1   | Root  |
| 2   | Inner |
| 3   | Leaf  |
| 4   | Leaf  |
| 5   | Leaf  |

**Explanation of Example Output 1:**

*   **Node 1 (id=1):** `p_id` is `NULL`, so it is the "Root".
*   **Node 2 (id=2):** `p_id` is 1 (has a parent), and it is a parent to nodes 4 and 5 (has children), so it is "Inner".
*   **Node 3 (id=3):** `p_id` is 1 (has a parent), and it is not a parent to any other node (no children - not listed as a `p_id` for any other node), so it is "Leaf".
*   **Node 4 (id=4):** `p_id` is 2 (has a parent), and it is not a parent to any other node (no children), so it is "Leaf".
*   **Node 5 (id=5):** `p_id` is 2 (has a parent), and it is not a parent to any other node (no children), so it is "Leaf".

**Example Input 2:**

**`Tree` Table:**

| id  | p\_id |
| --- | ----- |
| 1   | null  |

**Expected Output 2:**

| id  | type  |
| --- | ----- |
| 1   | Root  |

**Explanation of Example Output 2:**

*   **Node 1 (id=1):** `p_id` is `NULL`, so it is the "Root". Even if it's the only node, it's still considered the root.

**Note:** This question is the same as 3054: Binary Tree Nodes.

---

To solve this problem, we need to categorize each node in the tree as either "Root", "Inner", or "Leaf" based on its relationship with other nodes. Hereâ€™s the step-by-step solution:

---

### **1. Procedural Decomposition of the Solution**

1. **Identify the Root Node**:  
   - The root node is the one with `p_id` as `NULL` (or no parent).

2. **Identify Leaf Nodes**:  
   - Leaf nodes are those that do not have any child nodes.  
   - We can find these by checking which nodes do not appear in the `p_id` column of any other row.

3. **Identify Inner Nodes**:  
   - Inner nodes are those that have both a parent and at least one child.  
   - These nodes will appear in both the `id` column (as children) and the `p_id` column (as parents).

4. **Combine Results**:  
   - Categorize each node based on the above conditions and return the result.

---

### **2. Approach**

We will use SQL queries to:
- Identify the root node using a `WHERE` clause.
- Identify leaf nodes using a `NOT EXISTS` clause.
- Identify inner nodes by checking if a node has both a parent and a child.
- Combine these results using `UNION ALL`.

---

### **3. Query Solution**

```sql
SELECT id, 'Root' AS type
FROM Tree
WHERE p_id IS NULL

UNION ALL

SELECT id, 'Inner' AS type
FROM Tree
WHERE id IN (SELECT DISTINCT p_id FROM Tree)
  AND id IN (SELECT p_id FROM Tree GROUP BY p_id HAVING COUNT(id) > 1)

UNION ALL

SELECT id, 'Leaf' AS type
FROM Tree
WHERE id NOT IN (SELECT DISTINCT p_id FROM Tree WHERE p_id IS NOT NULL);
```

**Explanation:**

1. **Root Node**:  
   - `SELECT id, 'Root' AS type FROM Tree WHERE p_id IS NULL`  
   - Selects the node(s) with `p_id` as `NULL`, which is the root.

2. **Inner Nodes**:  
   - `SELECT id, 'Inner' AS type FROM Tree WHERE id IN (SELECT DISTINCT p_id FROM Tree) AND EXISTS (SELECT 1 FROM Tree WHERE p_id = Tree.id)`  
   - Selects nodes that appear as both `id` (child) and `p_id` (parent), meaning they have both a parent and at least one child.

3. **Leaf Nodes**:  
   - `SELECT id, 'Leaf' AS type FROM Tree WHERE id NOT IN (SELECT DISTINCT p_id FROM Tree WHERE p_id IS NOT NULL)`  
   - Selects nodes that do not appear in the `p_id` column, meaning they have no children.

---

### **4. Alternative Approach**

An alternative approach uses common table expressions (CTEs) for better readability:

```sql
WITH RecursiveTree AS (
    SELECT id, p_id,
           CASE WHEN p_id IS NULL THEN 'Root'
                WHEN p_id IN (SELECT DISTINCT p_id FROM Tree WHERE p_id IS NOT NULL) THEN 'Inner'
                ELSE 'Leaf' END AS type
    FROM Tree
)
SELECT id, type
FROM RecursiveTree;
```

**Explanation:**

- The CTE `RecursiveTree` categorizes each node based on whether it is a root, inner, or leaf node using a `CASE` statement.
- The final `SELECT` statement retrieves the `id` and `type` from the CTE.

Both approaches are valid and yield the same result. The choice depends on personal preference or specific database optimization considerations.
