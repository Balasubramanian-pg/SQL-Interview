# 3374. First Letter Capitalization

**1. Problem:**

**Task:** Transform text in the `content_text` column of the `user_content` table according to these rules:

*   **Rule 1: Word Capitalization:** Convert the first letter of each word to uppercase and the rest to lowercase.
*   **Rule 2: Hyphenated Words:** For words connected with a hyphen (`-`), capitalize the first letter of each part (before and after the hyphen).
*   **Rule 3: Preserve Formatting:** Keep all other formatting and spacing (like multiple spaces, tabs, etc.) exactly as they are in the original text.

**Example:**

*   Input: `"web-based FRONT-end development"`
*   Output: `"Web-Based Front-End Development"`

**2. My Thinking Process to Arrive at the Solution:**

*   **Initial Understanding & Rule Breakdown:** I first broke down the problem into its core requirements. It's not just simple word capitalization; the hyphen handling is key, and preserving original spacing is important.

*   **Considering Basic SQL String Functions (and their limitations):** I initially thought about using basic SQL string functions like `UPPER`, `LOWER`, `SUBSTRING`, and `REPLACE`.  However, I quickly realized:
    *   Simply using `INITCAP` (if available - and it's not standard across all SQL dialects and might not handle hyphens exactly as needed) wouldn't be sufficient for the hyphenated word rule.
    *   Directly replacing hyphens and then trying to capitalize would be complex and error-prone in SQL without a way to easily split strings into words and sub-words.
    *   Maintaining spacing while doing these manipulations would also be tricky with basic functions alone.

*   **Thinking about Word and Sub-word Splitting:**  I considered splitting the `content_text` into words (by spaces) and then further splitting words into sub-words (by hyphens).  If I could do this, I could process each sub-word individually.  However, standard SQL doesn't have easy, order-preserving string splitting functions built-in across all databases.

*   **Realizing the Need for Character-Level Processing:**  To handle the capitalization rules precisely and maintain spacing, I realized I needed a way to process the text character by character. This would give me the most control to decide when to capitalize and when to lowercase.

*   **Choosing Recursive CTE for Character Iteration:** Recursive CTEs in SQL are powerful for iterative processing. I recognized that I could use a recursive CTE to:
    *   Process the string character by character, position by position.
    *   Keep track of whether the *next* character should be capitalized (based on whether the *previous* character was a space or a hyphen).

*   **Developing the Capitalization Logic within the CTE:**
    *   **Base Case:**  Start by taking the first character of the string and always capitalizing it (as it's the start of the first word). Set a flag to indicate if the *next* character should be capitalized (initially based on whether the first character itself is a space or hyphen).
    *   **Recursive Step:** For each subsequent character:
        *   Check the "next capitalization" flag from the *previous* step.
        *   If the flag is set, capitalize the current character; otherwise, lowercase it.
        *   Update the "next capitalization" flag for the *next* character based on whether the *current* character is a space or a hyphen.

*   **Considering String Aggregation:** After processing each character in the CTE, I needed to put them back together into a single string.  I initially thought of `STRING_AGG` (common in SQL Server and PostgreSQL), but then remembered that MySQL uses `GROUP_CONCAT`.

*   **Addressing Database-Specific Syntax (and correcting for MySQL):**  Initially, I provided a solution using `STRING_AGG`, which is not MySQL compatible.  Upon receiving the error message, I recognized the database was likely MySQL and corrected the solution to use `GROUP_CONCAT` and `LENGTH` (MySQL-specific functions) to ensure compatibility.

**3. Solution (MySQL SQL Query):**

```sql
WITH cte AS (
    SELECT
        content_id,
        content_text,
        1 AS pos,
        UPPER(SUBSTRING(content_text, 1, 1)) AS converted_char,
        CASE WHEN SUBSTRING(content_text, 1, 1) IN (' ', '-') THEN 1 ELSE 0 END AS next_cap
    FROM user_content
    UNION ALL
    SELECT
        cte.content_id,
        cte.content_text,
        cte.pos + 1 AS pos,
        CASE
            WHEN cte.next_cap = 1 THEN UPPER(SUBSTRING(cte.content_text, cte.pos + 1, 1))
            ELSE LOWER(SUBSTRING(cte.content_text, cte.pos + 1, 1))
        END AS converted_char,
        CASE
            WHEN SUBSTRING(cte.content_text, cte.pos + 1, 1) IN (' ', '-') THEN 1
            ELSE 0
        END AS next_cap
    FROM cte
    WHERE cte.pos < LENGTH(cte.content_text)
)
SELECT
    content_id,
    content_text AS original_text,
    GROUP_CONCAT(converted_char ORDER BY pos SEPARATOR '') AS converted_text
FROM cte
GROUP BY content_id, content_text;
```

**4. Explanation of the Solution:**

*   **`WITH cte AS (...)` (Common Table Expression):**
    *   This defines a temporary, named result set called `cte`. It's not a real table on disk; it exists only for this query's execution. We use it to perform the character-by-character processing.

*   **Base Case (First `SELECT` in `UNION ALL`):**
    ```sql
    SELECT
        content_id,
        content_text,
        1 AS pos,
        UPPER(SUBSTRING(content_text, 1, 1)) AS converted_char,
        CASE WHEN SUBSTRING(content_text, 1, 1) IN (' ', '-') THEN 1 ELSE 0 END AS next_cap
    FROM user_content
    ```
    *   This is the starting point of the recursion. It selects from your `user_content` table and initializes:
        *   `pos`:  Position of the character in the string (starts at 1).
        *   `converted_char`: The *first character* of `content_text` converted to uppercase.
        *   `next_cap`: A flag (0 or 1). It's set to `1` if the *first character* is a space or hyphen, indicating the *next* character should be capitalized; otherwise, it's `0`.

*   **Recursive Case (Second `SELECT` in `UNION ALL`):**
    ```sql
    SELECT
        cte.content_id,
        cte.content_text,
        cte.pos + 1 AS pos,
        CASE
            WHEN cte.next_cap = 1 THEN UPPER(SUBSTRING(cte.content_text, cte.pos + 1, 1))
            ELSE LOWER(SUBSTRING(cte.content_text, cte.pos + 1, 1))
        END AS converted_char,
        CASE
            WHEN SUBSTRING(cte.content_text, cte.pos + 1, 1) IN (' ', '-') THEN 1
            ELSE 0
        END AS next_cap
    FROM cte
    WHERE cte.pos < LENGTH(cte.content_text)
    ```
    *   This part does the iterative processing. It selects from the `cte` itself (making it recursive):
        *   `pos + 1`: Moves to the next character position.
        *   `converted_char`:  **Core Logic:**
            *   `CASE WHEN cte.next_cap = 1 THEN UPPER(...) ELSE LOWER(...) END`:  If `next_cap` from the *previous character* was `1`, it capitalizes the *current character*; otherwise, it lowercases the current character.
        *   `next_cap`:  Updates the flag for the *next* character. It's set to `1` if the *current character* is a space or hyphen, and `0` otherwise.
        *   `WHERE cte.pos < LENGTH(cte.content_text)`:  The recursion continues until all characters in `content_text` are processed.

*   **Final `SELECT` Statement (Outside the CTE):**
    ```sql
    SELECT
        content_id,
        content_text AS original_text,
        GROUP_CONCAT(converted_char ORDER BY pos SEPARATOR '') AS converted_text
    FROM cte
    GROUP BY content_id, content_text;
    ```
    *   This part retrieves the results from the `cte`:
        *   `content_id`: Selects the content ID.
        *   `content_text AS original_text`: Selects the original text, aliased for clarity.
        *   `GROUP_CONCAT(converted_char ORDER BY pos SEPARATOR '') AS converted_text`:  **String Aggregation (MySQL Specific):**
            *   `GROUP_CONCAT(...)`:  Concatenates all the `converted_char` values for each `content_id` back into a single string.
            *   `ORDER BY pos`:  Ensures the characters are combined in the correct original order.
            *   `SEPARATOR ''`:  Specifies no separator between characters.
        *   `GROUP BY content_id, content_text`: Groups the rows by `content_id` and `content_text` to allow `GROUP_CONCAT` to work correctly for each unique text.

**5. MySQL Specific Notes:**

*   **`GROUP_CONCAT` (instead of `STRING_AGG`):**  MySQL uses `GROUP_CONCAT` for string aggregation, which is different in syntax from `STRING_AGG` used in SQL Server and PostgreSQL.
*   **`LENGTH` (instead of `LEN`):** MySQL uses `LENGTH()` to get the length of a string, while `LEN()` is used in SQL Server.
*   **Case Sensitivity (Generally Insensitive for Object Names):** MySQL is generally case-insensitive for table and column names, but it's still good practice to be consistent with casing to avoid potential issues in different environments.

This detailed breakdown should give you a clear understanding of the problem, the thought process behind the solution, and how the MySQL SQL query works to achieve the desired text transformation.
